// -*- C++ -*-
// 
// file persister.h
// 
// A persister is a handle on an object, which knows
// how to read this object from an input stream, or
// how to write it to an output stream. The stream 
// is generic and can be implemented many ways.
// 
#ifndef PERSISTER_H
#define PERSISTER_H


#include "objio.h"

#define CLASS_VERSION(className,id) \
 static const unsigned short __version__=id; \
 friend class persister<className>;


class obj_intput_base;
class obj_output_base;

//class persister_base {
//public:
//  virtual unsigned int version() const=0;
//  virtual void         read(obj_input_base const&)=0;
//  virtual void         write(obj_output_base&) const=0;
//};



template<class T>
class handle {
public:
  handle() : obj_(new T), own_obj_(true) { }
  handle(T* t) : obj_(t), own_obj_(false) { }
  handle(handle<T> const& h) : obj_(0) { copy(h); }
  ~handle() { if(obj_&&own_obj_) delete obj_; };

  inline handle<T>&  operator=(T* t) { 
    clear_(); 
    obj_=t; own_obj_=false; 
    return *this; 
  }
  
  inline T*          operator->() { return obj_; }
  inline T&          operator*() { return *obj_; }
  inline T const&    operator*() const { return *obj_; }
  
  inline void        copy(handle<T> const& h) { 
    obj_=h.obj_; 
    own_obj_=false; 
  }
  
  inline handle<T> const& operator=(handle<T> const& t) { 
    copy(t); 
    return *this; 
  }

protected:
  T*   obj_;
  bool own_obj_;
  
  inline void clear_() { 
    if(obj_&&own_obj_) delete obj_; 
    obj_=0; 
    own_obj_=false; 
  }
};



// Default persister (empty)
template<class T> 
class persister : public handle<T> {
public:
  persister() : handle<T>() {}
  persister<T>(T& obj) : handle<T>(&obj) {}
  persister<T>(T const & obj) : handle<T>(const_cast<T*>(&obj)) {}// I know, that's UGLY.
  persister(persister<T> const& p) : handle<T>(p.obj_) {}
  ~persister() {}
  
  unsigned int         version() const { return 0; }
  std::string          name() const { return (std::string)"unsupported"; }
  unsigned int         size() const { return 0; }
  std::string          name(unsigned int i) const { return (std::string)""; }
  std::string          type(unsigned int i) const { return (std::string)""; }
  
protected:
  template<class IOS>
  void   write_members(obj_output<IOS>& oo) const {}
  
  template<class IOS>
  void   read_members(obj_input<IOS> const& oi) {}

  template<class U> friend class obj_input;
  template<class U> friend class obj_output;
};


template<class T, class IOS>
obj_output<IOS>& operator<<(obj_output<IOS>& oo, T const& p)
{
  persister<T> pp(p);
  oo.write(pp);
  return oo;
}

template<class T, class IOS>
obj_input<IOS> const& operator>>(obj_input<IOS> const& oi, T& p)
{
  persister<T> pp(p);
  oi.read(pp);
  return oi;
};


/* 
   Generated by dictgen ... 


   template<class T, class streamer>
   class persister : public handle<T>, public persister_base {
   public:
   persister() : handle<T>() {}
   persister(persister<T> const& p) : handle<T>(p.obj_) {}
   persister(T* t) : handle<T>(t) {}
   // Implement a const_persister here ! 
   // that stuff is too ugly !
   persister(T const* t) : handle<T>(const_cast<char*>(t)) {}
   ~persister() { }
   
   static const char*    className() const;
   static unsigned int   size() const;
   static const char*    name(int i) const;
   
   template<class IOS>
   void                  read(obj_input<IOS> const&);
   
   template<class IOS>
   void                  write(obj_output<IOS>& oo) const {
   obj_->write(oo);
   }
   
   private:
   streamer strm_;
   friend streamer;
   };
*/


#endif

